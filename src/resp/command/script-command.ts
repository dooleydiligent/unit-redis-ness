import { MaxParams, MinParams, Name } from '../../decorators';
import { Logger } from '../../logger';
import { IRequest } from '../../server/request';
import { Database } from '../data/database';
import { RedisToken } from '../protocol/redis-token';
import { IRespCommand } from './resp-command';
import * as util from 'util';

const fengari = require('fengari');
const lua = fengari.lua;
const lauxlib = fengari.lauxlib;
const lualib = fengari.lualib;
/**
 * Available since 2.6.0.
 * 
 * SCRIPT LOAD script
 *
 * Load a script into the scripts cache, without executing it. After the specified command
 * is loaded into the script cache it will be callable using EVALSHA with the correct SHA1
 * digest of the script, exactly like after the first successful invocation of EVAL.
 *
 * The script is guaranteed to stay in the script cache forever (unless SCRIPT FLUSH is called).
 * **unit-redis-ness does not persist the script thru restarts**
 *
 * The command works in the same way even if the script was already present in the script cache.
 *
 * Please refer to the EVAL documentation for detailed information about Redis Lua scripting.
 *
 * **Return value**<br>
 * Bulk string reply This command returns the SHA1 digest of the script added into the script cache.
 */
@MaxParams(-1)
@MinParams(1)
@Name('script')
export class ScriptCommand implements IRespCommand {
  private logger: Logger = new Logger(module.id);
  private DEFAULT_ERROR: string = 'ERR Unknown subcommand or wrong number of arguments for \'%s\'. Try SCRIPT HELP.';
  public execute(request: IRequest, db: Database): RedisToken {
    this.logger.debug(`${request.getCommand()}.execute(%s)`, request.getParams());
    switch (request.getCommand().toLowerCase()) {
      case 'eval':
        // Replace the sha1 in the cache
        try {
          const sha1: string = this.loadScript(request, 0);
          return this.executeLua(sha1, request)
        } catch (ex) {
          this.logger.warn(`Exception while loading script: %s`, ex);
          return RedisToken.error(ex);
        }
      case 'evalsha':
        const sha1: string = request.getParam(0);
        const code: string = request.getServerContext().getScript(sha1);
        if (!code) {
          return RedisToken.error('NOSCRIPT No matching script. Please use EVAL.');
        }
        return this.executeLua(sha1, request);
      default:
        switch (request.getParam(0)) {
          case 'load':
            // The script must be compiled before saving
            // ERR Error compiling script (new function): user_script:2: '}' expected (to close '{' at line 1) near 'end'
            // Where 'user_script:2' is "user_script:" plus an ordinal script counter.
            // The error is apparently generated by lua
            try {
              const sha1 = this.loadScript(request, 1);
              return RedisToken.string(sha1);
            } catch (ex) {
              this.logger.warn(`Exception while loading script: %s`, ex);
              return RedisToken.error(ex);
            }
          case 'exists':
            // integer 0/1
            const exists: any = request.getServerContext().getScript(request.getParam(1));
            this.logger.debug(`EXISTS is ${request.getServerContext().scriptExists(request.getParam(1))}`);
            this.logger.debug(`The retured value is "%s"`, exists);
            return RedisToken.string(request.getServerContext().scriptExists(request.getParam(1)) ? '1' : '0');
          case 'flush':
          case 'kill':
          case 'debug':
          default:
            return RedisToken.error(this.DEFAULT_ERROR.replace('%s', request.getParam(0)));
        }
    }
  }

  /*
  const thread_status = {
    LUA_OK:        0,
    LUA_YIELD:     1,
    LUA_ERRRUN:    2,
    LUA_ERRSYNTAX: 3,
    LUA_ERRMEM:    4,
    LUA_ERRGCMM:   5,
    LUA_ERRERR:    6
  };
*/
  /**
   * Attempt to parse a lua script.
   * Returns a sha1 and stores the script if it can
   * @param request the client request
   * @returns
   */
  private loadScript(request: IRequest, scriptIndex: number): string {
    const code = request.getParam(scriptIndex);
    this.logger.debug(`loadScript(): Validating lua script "%s"`, code);
    const L: any = lauxlib.luaL_newstate();
    this.logger.debug(`Opening lua libraries`);
    lualib.luaL_openlibs(L);
    const loadStatus = lauxlib.luaL_loadstring(L, fengari.to_luastring(code));
    if (loadStatus !== lua.LUA_OK) {
      this.logger.warn(`Caught loadStatus error "%s"`, loadStatus)
      let info: string = 'Unknown LUA error %s';
      switch (loadStatus) {
        case lua.LUA_YIELD: //     1,
          info = 'LUA YIELD Error evaluating: "%s"'
          break;
        case lua.LUA_ERRRUN:  //    2,
          info = 'LUA RUN Error evaluating: "%s"'
          break;
        case lua.LUA_ERRSYNTAX: // 3,
          info = 'LUA SYNTAX Error evaluating: "%s"'
          break;
        case lua.LUA_ERRMEM: //   4,
          info = 'LUA MEMORY Error: evaluating "%s"'
          break;
        case lua.LUA_ERRGCMM: //  5,
          info = 'LUA GC Error: evaluating "%s"'
          break;
        case lua.LUA_ERRERR: //   6
          info = 'LUA ERR Error: evaluating "%s"'
          break;
      }
      throw new Error(info.replace('%s', code));
    }
    this.logger.debug(`Caching script`);
    const sha1: string = request.getServerContext().setScript(code)
    this.logger.debug(`Script sha1 is "%s"`, sha1);
    return sha1;
  }
  private executeLua(sha1: string, request: IRequest): RedisToken {
    this.logger.debug(`executeLua sha1: %s`, sha1);
    let returnValue: RedisToken;
    // Validate the 2nd parameter
    // evalsha sha1 <key_count> ...keys ...argv
    // eval code <key_count> ...keys ...argv
    const code: string = request.getServerContext().getScript(sha1);
    const keycount: string = request.getParam(1);
    this.logger.debug(`key count %s`, keycount);
    if (isNaN(Number(keycount))) {
      return RedisToken.error('ERR value is not an integer or out of range');
    }
    if (Number(keycount) < 0) {
      return RedisToken.error('ERR Number of keys can\'t be negative');
    }
    const keys: string[] = [];
    const argv: string[] = [];
    for (let index = 2; index < request.getParams().length; index++) {
      if (index > Number(keycount) + 1) {
        argv.push(request.getParam(index));
      } else {
        keys.push(request.getParam(index));
      }
    }
    // Setup the script
    const L: any = lauxlib.luaL_newstate();
    this.logger.debug(`executeLua: Opening lua libraries`);
    lualib.luaL_openlibs(L);
    this.logger.debug(`Creating ARGV table`);
    lua.lua_createtable(L, argv.length, 0);
    for (let index = 0; index < argv.length; index++) {
      lua.lua_pushstring(L, argv[index]);
      lua.lua_seti(L, -2, index + 1);
    }
    lua.lua_setglobal(L, fengari.to_luastring('ARGV'));

    this.logger.debug(`Creating KEYS tables`);
    lua.lua_createtable(L, keys.length, 0);
    for (let index = 0; index < keys.length; index++) {
      lua.lua_pushstring(L, keys[index]);
      lua.lua_seti(L, -2, index + 1);
    }
    lua.lua_setglobal(L, fengari.to_luastring('KEYS'));

    this.logger.debug(`executeLua: Validating lua script "%s"`, code);
    // const loadStatus = lauxlib.luaL_loadstring(L, fengari.to_luastring(`${tables}\n${code}`));
    const loadStatus = lauxlib.luaL_loadstring(L, fengari.to_luastring(`${code}`));
    if (loadStatus !== lua.LUA_OK) {
      this.logger.warn(`Unexpected error parsing sha1: "${sha1}"`);
      throw new Error(`Unexpected error parsing sha1: "${sha1}"`);
    }
    this.logger.debug(`Calling script "%s" with ARGV: ${JSON.stringify(argv)} and KEYS: ${JSON.stringify(keys)}`, code);
    const ok = lua.lua_call(L, 0, lua.LUA_MULTRET);
    // if (ok === lua.LUA_OK || ok === undefined) {
    let returnedValue: any = 'UNKNOWN';
    if (ok === undefined) { // A string return
      this.logger.debug(`The LUA call was undefined`);
      const stack: number = lua.lua_gettop(L);
      this.logger.debug(`The stack top is ${stack}`);
      if (stack === 0) {
        returnValue = RedisToken.NULL_STRING;
      } else {
        this.dumpStack(L, stack);
        switch (true) {
          case lua.lua_istable(L, -1):
            const table: RedisToken[] = [];
            this.logger.debug(`return type is TABLE`);
            // get each element of the table
            for (let i = 0; i < 3; i++) {
              this.logger.debug(`Getting element ${i}`);
              lua.lua_pushstring(L, 'key');
              const element = lua.lua_gettable(L, -2);
              this.logger.debug(`got element ${element}`);
              table.push(RedisToken.string(element));
              lua.lua_pop(L, 1);
            }
            //          returnedValue = lua.lua_gettable(L, -1);
            returnedValue = RedisToken.array(table);
            this.logger.debug(`The table is %j`, returnedValue);
            break;
          // case lua.lua_isnumber(L, -1):
          //   this.logger.debug(`return type is NUMBER`);
          //   returnedValue = lua.lua_tojsstring(L, -1);
          //   break;
          case lua.lua_isstring(L, -1):
            returnedValue = lua.lua_tojsstring(L, -1);
            break;
        }
        //      this.logger.debug(`ISTABLE is ${lua.lua_istable(L, -1)}`);
        returnValue = RedisToken.string(returnedValue);
      }
    } else {
      if (ok === lua.LUA_OK) {
        this.logger.warn(`CALL WAS LUA_OK!`);
        const returnArray: any[] = [];
        let le = 1;
        let ar = new lua.lua_Debug();
        let li = 1;
        //      if (!returnString) {
        this.logger.debug(`Scanning the stack`);
        while (lua.lua_getstack(L, le, ar)) {
          li = le; le *= 2;
          this.logger.debug(`li = ${li}, le = ${le}`);
        }
        this.logger.debug(`Found stack upper bound at ${le - 1}`);
        returnValue = RedisToken.string('LUA_OK');
      } else {
        this.logger.warn(`The LUA call was NOT OK: ${ok}`);
        returnValue = RedisToken.error(lauxlib.luaL_error(L, lua.to_luastring('processing error (%s)'), code))
      }
    }
    this.logger.debug(`Releasing lua state`);
    lua.lua_close(L);
    return returnValue;
  }
  private dumpStack(L: any, top: number): void {
    let dump: string = '';
    for (let i = 1; i <= top; i++) {  /* repeat for each level */
      let t: number = lua.lua_type(L, i);
      switch (t) {
        case lua.LUA_TSTRING:  /* strings */
          dump += util.format(`STRING: '%s'`, lua.lua_tostring(L, i));
          break;
        case lua.LUA_TBOOLEAN:  /* booleans */
          dump += util.format(`BOOLEAN: '%s'`, lua.lua_toboolean(L, i) ? 'true' : 'false');
          break;
        case lua.LUA_TNUMBER:  /* numbers */
          dump += util.format(`NUMBER: '%s'`, lua.lua_tonumber(L, i));
          break;
        default:  /* other values */
          const typename: any[] = lua.lua_typename(L, t);
          let typenameString: string = '';
          typename.forEach((c) => {
            typenameString += String.fromCharCode(c)
          });
          dump += util.format(`OTHER: '%s'`, typenameString);
          if (typenameString === 'table') {
            this.logger.debug(`Invoking luaL_len against i`);
            const size = lauxlib.luaL_len(L, i);
            this.logger.debug(`Table ${i} size is ${size}`);

            /* table is in the stack at index 'i' */
            lua.lua_pushnil(L);  /* first key */
            let temp: string = '';
            while (lua.lua_next(L, i) != 0) {
              /* uses 'key' (at index -2) and 'value' (at index -1) */
              // temp =  util.format("%s - %s\n",
              //   lua.lua_typename(L, lua.lua_type(L, -2)),
              //   lua.lua_typename(L, lua.lua_type(L, -1)));
              const element: any[] = lua.lua_tostring(L, -1);
              element.forEach((c) => {
                temp += String.fromCharCode(c)
              });

              dump += util.format(`\nELEMENT: '%s'`, temp);

              /* removes 'value'; keeps 'key' for next iteration */
              lua.lua_pop(L, 1);
              // this.logger.debug(`lua_pop: ${temp}`);
              // dump += `${temp},`;
              temp = '';
            }
          }
          break;
      }
      dump += '\n';  /* put a separator */
    }
    this.logger.debug(`DUMP STACK: ${dump}`);
  }
}
