import { MaxParams, MinParams, Name } from '../../decorators';
import { Logger } from '../../logger';
import { IRequest } from '../../server/request';
import { Database } from '../data/database';
import { RedisToken } from '../protocol/redis-token';
import { IRespCommand } from './resp-command';

const fengari = require('fengari')
const lua = fengari.lua
const lauxlib = fengari.lauxlib
const lualib = fengari.lualib
// const flua = require('flua');
/**
 * Available since 2.6.0.
 * 
 * SCRIPT LOAD script
 *
 * Load a script into the scripts cache, without executing it. After the specified command
 * is loaded into the script cache it will be callable using EVALSHA with the correct SHA1
 * digest of the script, exactly like after the first successful invocation of EVAL.
 *
 * The script is guaranteed to stay in the script cache forever (unless SCRIPT FLUSH is called).
 * **unit-redis-ness does not persist the script thru restarts**
 *
 * The command works in the same way even if the script was already present in the script cache.
 *
 * Please refer to the EVAL documentation for detailed information about Redis Lua scripting.
 *
 * **Return value**<br>
 * Bulk string reply This command returns the SHA1 digest of the script added into the script cache.
 */
@MaxParams(-1)
@MinParams(1)
@Name('script')
export class ScriptCommand implements IRespCommand {
  private logger: Logger = new Logger(module.id);
  private DEFAULT_ERROR: string = 'ERR Unknown subcommand or wrong number of arguments for \'%s\'. Try SCRIPT HELP.';
  public execute(request: IRequest, db: Database): RedisToken {
    this.logger.debug(`${request.getCommand()}.execute(%s)`, request.getParams());
    switch (request.getCommand().toLowerCase()) {
      case 'eval':
        // Replace the sha1 in the cache
        try {
          const sha1: string = this.loadScript(request, 0);
          return this.executeLua(sha1, request)
        } catch (ex) {
          this.logger.warn(`Exception while loading script: %s`, ex);
          return RedisToken.error(ex);
        }
      case 'evalsha':
        const sha1: string = request.getParam(0);
        const code: string = request.getServerContext().getScript(sha1);
        if (!code) {
          return RedisToken.error('NOSCRIPT No matching script. Please use EVAL.');
        }
        return this.executeLua(sha1, request);
      default:
        switch (request.getParam(0)) {
          case 'load':
            // The script must be compiled before saving
            // ERR Error compiling script (new function): user_script:2: '}' expected (to close '{' at line 1) near 'end'
            // Where 'user_script:2' is "user_script:" plus an ordinal script counter.
            // The error is apparently generated by lua
            try {
              const sha1 = this.loadScript(request, 1);
              return RedisToken.string(sha1);
            } catch (ex) {
              this.logger.warn(`Exception while loading script: %s`, ex);
              return RedisToken.error(ex);
            }
          case 'exists':
            // integer 0/1
            const exists: any = request.getServerContext().getScript(request.getParam(1));
            this.logger.debug(`EXISTS is ${request.getServerContext().scriptExists(request.getParam(1))}`);
            this.logger.debug(`The retured value is "%s"`, exists);
            return RedisToken.string(request.getServerContext().scriptExists(request.getParam(1)) ? '1' : '0');
          case 'flush':
          case 'kill':
          case 'debug':
          default:
            return RedisToken.error(this.DEFAULT_ERROR.replace('%s', request.getParam(0)));
        }
    }
  }

  /*
  const thread_status = {
    LUA_OK:        0,
    LUA_YIELD:     1,
    LUA_ERRRUN:    2,
    LUA_ERRSYNTAX: 3,
    LUA_ERRMEM:    4,
    LUA_ERRGCMM:   5,
    LUA_ERRERR:    6
  };
*/
  /**
   * Attempt to parse a lua script.
   * Returns a sha1 and stores the script if it can
   * @param request the client request
   * @returns
   */
  private loadScript(request: IRequest, scriptIndex: number): string {
    const code = request.getParam(scriptIndex);
    this.logger.debug(`loadScript(): Validating lua script "%s"`, code);
    const L: any = lauxlib.luaL_newstate();
    this.logger.debug(`Opening lua libraries`);
    lualib.luaL_openlibs(L);
    const loadStatus = lauxlib.luaL_loadstring(L, fengari.to_luastring(code));
    if (loadStatus !== lua.LUA_OK) {
      this.logger.warn(`Caught loadStatus error "%s"`, loadStatus)
      let info: string = 'Unknown LUA error %s';
      switch (loadStatus) {
        case lua.LUA_YIELD: //     1,
          info = 'LUA YIELD Error evaluating: "%s"'
          break;
        case lua.LUA_ERRRUN:  //    2,
          info = 'LUA RUN Error evaluating: "%s"'
          break;
        case lua.LUA_ERRSYNTAX: // 3,
          info = 'LUA SYNTAX Error evaluating: "%s"'
          break;
        case lua.LUA_ERRMEM: //   4,
          info = 'LUA MEMORY Error: evaluating "%s"'
          break;
        case lua.LUA_ERRGCMM: //  5,
          info = 'LUA GC Error: evaluating "%s"'
          break;
        case lua.LUA_ERRERR: //   6
          info = 'LUA ERR Error: evaluating "%s"'
          break;
      }
      throw new Error(info.replace('%s', code));
    }
    this.logger.debug(`Caching script`);
    const sha1: string = request.getServerContext().setScript(code)
    this.logger.debug(`Script sha1 is "%s"`, sha1);
    return sha1;
  }
  private executeLua(sha1: string, request: IRequest): RedisToken {
    this.logger.debug(`executeLua sha1: %s`, sha1);
    // Validate the 2nd parameter
    // evalsha sha1 <key_count> ...keys ...argv
    // eval code <key_count> ...keys ...argv
    const code: string = request.getServerContext().getScript(sha1);
    const keycount: string = request.getParam(1);
    this.logger.debug(`key count %s`, keycount);
    if (isNaN(Number(keycount))) {
      return RedisToken.error('ERR value is not an integer or out of range');
    }
    if (Number(keycount) < 0) {
      return RedisToken.error('ERR Number of keys can\'t be negative');
    }
    const keys: string[] = [];
    const argv: string[] = [];
    for (let index = 2; index < request.getParams().length; index++) {
      if (index > Number(keycount) + 1) {
        argv.push(request.getParam(index));
      } else {
        keys.push(request.getParam(index));
      }
    }
    // Setup the script
    const L: any = lauxlib.luaL_newstate();
    this.logger.debug(`executeLua: Opening lua libraries`);
    lualib.luaL_openlibs(L);
    this.logger.debug(`executeLua: Validating lua script "%s"`, code);
    const loadStatus = lauxlib.luaL_loadstring(L, fengari.to_luastring(code));
    if (loadStatus !== lua.LUA_OK) {
      this.logger.warn(`Unexpected error parsing sha1: "${sha1}"`);
      throw new Error(`Unexpected error parsing sha1: "${sha1}"`);
    }
    // Push keys
    this.logger.debug(`Processing KEYS: ${keys}`);
    lua.lua_createtable(L, keys.length, 0); // see flua_pusharray
    for (let index = 0; index < keys.length; index++) {
      lua.lua_pushliteral(keys[index]);
      lua.lua_seti(L, -2, index + 1);
    }
    lua.lua_setglobal(L, fengari.to_luastring('KEYS'))
    // Push arguments
    this.logger.debug(`Processing ARGV: ${argv}`);
    lua.lua_createtable(L, argv.length, 0); // see flua_pusharray
    for (let index = 0; index < argv.length; index++) {
      lua.lua_pushliteral(argv[index]);
      lua.lua_rawset(L, -2, index + 1);
    }
    lua.lua_setglobal(L, fengari.to_luastring('ARGV'))

    this.logger.debug(`pcalling script "%s" with ARGV: ${JSON.stringify(argv)} and KEYS: ${JSON.stringify(keys)}`, code);
//    const ok = lauxlib.luaL_dostring(L, 'LUA_INIT', 'LUA_INIT');
    const ok = lua.lua_call(L, 0, -1);
    if (ok === lua.LUA_OK || ok === undefined) {
      this.logger.debug(`The LUA call was LUA_OK!`);
      return RedisToken.string(lua.lua_tojsstring(L, -1));
    } else {
      this.logger.warn(`The LUA call was NOT OK: ${ok}`);
      return RedisToken.error(this.DEFAULT_ERROR.replace('%s', request.getCommand()));
    }
  }
}
